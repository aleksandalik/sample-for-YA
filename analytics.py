#!/usr/bin/env python
# coding: utf-8

# In[ ]:


import pandas as pd
import sklearn as sk
from datetime import datetime
from seaborn import sns
import numpy as np


# Загружаем данные (предварительно преобразованные из файла &Enqueue in KMP в .txt) и приводим их к одному типу (datetime, float)

# In[3]:


purchases = pd.read_csv('E:\purchases.txt', sep='\t')
purchases.revenue = purchases.revenue.apply(lambda row: float(row.replace(',','.')))
purchases.buy_ts = purchases.buy_ts.apply(lambda row: datetime.strptime(row, '%d.%m.%Y %H:%M:%S'))
purchases.insert(0,'date',purchases.buy_ts.apply(lambda row: row.date()).astype('datetime64'))

visits = pd.read_csv(r'E:\visits.txt', sep='\t')
visits.end_ts = visits.end_ts.astype('datetime64')
visits.start_ts = visits.start_ts.astype('datetime64')
visits.start_dt = visits.start_dt.astype('datetime64')
visits.insert(1,'end_date',visits.end_ts.apply(lambda row: row.date()).astype('datetime64'))


# Убедимся, что формат данных подходит, пропуски отсутствуют

# In[19]:


print(purchases.info(),
      visits.info())


# Для дальнейшего анализа связи заказов с источниками удаляем все повторяющиеся сессии одного пользователя с одного устройства через один источник (т.е. возможные "повторные клики" за которые (в идеале) не оплачивается реклама; оставляем лишь одну сессию), чтобы максимально точно приблизиться к реальной статистике заказов и источников переходов

# In[27]:


visits.sort_values(['uid','end_ts']).drop_duplicates(subset=['uid','start_ts','source_id','device'], keep='last', inplace=True)
visits.sort_values(['uid','end_ts']).drop_duplicates(subset=['uid','end_ts','source_id','device'], keep='last', inplace=True)


# Посчитаем некоторые простые показатели по данным (с учетом того, что 57 покупок в таблице purchases проходят с revenue = 0; предположим, что эти данные нерелевантны) 

# In[28]:


total_revenue = purchases.revenue.sum() #370 824 у.е. было получено за год
total_uids = len(pd.unique(purchases[purchases.revenue>0].uid)) #55 777 уникальных пользователей, совершавших покупки за год
visitors = len(pd.unique(visits.uid)) #380 121 уникальных посетителей сервиса всего
total_visits = len(visits) #720 679 переходов


# Подтягиваем к каждой покупке сессию, в рамках которой (скорее всего) был осуществлен заказ.
# Однако тут не все так просто и существуют ситуации, в которых один пользователь сидел с нескольких устройств во время покупки.
# Присоединяем покупки или к дате старта сессии, или к дате окончания. 

# In[29]:


merged_df1 = purchases.merge(visits, how='left',left_on=['uid','date'], right_on=['uid','start_dt'])
merged_df2 = purchases.merge(visits, how='left',left_on=['uid','date'], right_on=['uid','end_date'])
merged = pd.concat([merged_df1, merged_df2]).drop_duplicates().dropna()
merged = merged[(merged.start_ts<=merged.buy_ts) & (merged.end_ts>=merged.buy_ts)].drop_duplicates(['uid','buy_ts'])


# Поскольку реклама (рекламные переходы) скорее всего побуждает к покупкам непостоянных пользователей (клиентов), определим, как много у нас пользователей, заказывающих не больше 1,3,5 раз, и сколько они приносят прибыли

# In[30]:


pivot1 = pd.pivot_table(purchases, values=['revenue'], index=['uid'], aggfunc=['count','sum'])
pivot1[(pivot1[('count','revenue')]==1) 
       & (pivot1[('sum','revenue')]>0)].sum() #47 099 (84,4% от всех когда-либо что-либо купивших) 
                                              # пользователей сделали всего 1 покупку за год и принесли 186 670 у.е. 
                                              # (50% от всего дохода)

pivot1[(pivot1[('count','revenue')]<=3) 
       & (pivot1[('sum','revenue')]>0)].count()
                                    #.sum()  #54 743 (98,2% от всех когда-либо что-либо купивших) 
                                               # пользователей сделали всего 1 покупку за год и принесли 258 793 у.е. 
                                               # (70% от всего дохода)
pivot1[(pivot1[('count','revenue')]<=4) 
       & (pivot1[('sum','revenue')]>0)].sum()
                                    #.sum()  #55 220 (99% от всех когда-либо что-либо купивших) 
                                               # пользователей сделали всего 1 покупку за год и принесли 268 098 у.е. 
                                               # (72,3% от всего дохода)

pivot1[(pivot1[('count','revenue')]<=5) 
       & (pivot1[('sum','revenue')]>0)].count()
                                    #.sum()  #55 418 (99,4% от всех когда-либо что-либо купивших) 
                                               # пользователей сделали всего 1 покупку за год и принесли 273 150 у.е. 
                                               # (73,6% от всего дохода)
         


# Чем выше ставим количество заказов на пользователя, тем меньше видим прирост в количестве что-либо заказавших за год. 
# Так, если бы рассматривали количество заказавших что-либо меньше 7 раз, то вывелось бы 55 520 пользователей (всего на 102 чел больше, чем 55 418).
# 
# Предположим, что людей, заказавшие что-либо за год больше 5 раз (не сегментируя отдельных покупателей и не углубляясь в RFM-анализ), можно считать постоянными клиентами, поэтому их рассматривать при анализе CAC и CPS не будем.

# In[31]:


pivot2 = pivot1[(pivot1[('count','revenue')]<=5) 
       & (pivot1[('sum','revenue')]>0)]
pivot2.sort_values([('sum','revenue')],ascending=False).head(5)


# Даже если мы откинули лояльных пользователей, у нас все равно остаются выбросы, но уже по заказам. Последняя строка в предыдущей ячейке показала, что есть резко выделяющееся значение дохода, принесенного одним пользователем (1186 у.е. с 3 заказов). Попробуем избавиться от резко-выделяющихся значений, и чтобы меньше ломать голову над медианой или средним, найдем по 1й и 99й перцентили, отбросим их и рассчитаем среднюю и медианную по покупке

# In[32]:


#Расчёт средних и медиан по покупкам
purchases.revenue[(purchases.revenue.between(purchases.revenue.quantile(0.01),purchases.revenue.quantile(0.99)))
         &(purchases.uid.isin(pivot1.index))].median() #66 120 заказов, со средней ценой 3.8 и медианной ценой заказа 2.44
purchases.revenue.mean() #75 716 заказов со средней ценой 4.9 и медианной ценой заказа 2.55


# In[ ]:


#Расчёт средних и медиан по одному платящему пользователю за год
pivot2[('sum','revenue')][(pivot1[('sum','revenue')] > pivot2[('sum','revenue')].quantile(0.01)) 
       &(pivot2[('sum','revenue')] < pivot2[('sum','revenue')].quantile(0.99))].median()
                                                                        # В среднем один пользователь приносит 4.34 за год;
                                                                        # Медианный доход от одного пользователя за год - 2.93


# Так, согласно расчёту (1 ячейка сверху) получилось среднее значение заказа в 3.8 у.е., а медианное значение - 2.44 у. е.
# (для сравнения также были рассчитаны значения по первоначальному набору данных, и показатели завышены значительно - на 29% и 4.5% соответственно, что означает, что отсеивание лишнего прошло не зря)
# 
# По полученным данным можно сделать вывод о значительном различии между средней и медианой, и при определении CPS, на мой взгляд, следует ориентироваться на медиану - 2.44 у.е.,  чтобы достичь окупаемости за год. 
# Очевидно, на расчёт CPS повлияют рыночные цены рекламного рынка, однако при исходных условиях поставленной задачи, для окупаемости  можно платить 2.44 у.е. за привлечение одного платящего (CPS), а 2.93 (2 ячейка сверху) - за одного НОВОГО платящего (из расчёта, что один пользователь в среднем принесет 2.93 - 4.34 у.е. за год). 

# Однако, можно также проверить - есть ли какие-то неэффективные источники, с которых пользователи приходят на сервис (а также девайсы, используемые ими)

# In[ ]:


#Sources
merged[merged.revenue>0].pivot_table('revenue',['source_id'],aggfunc=['count','sum','mean'])
#Devices
merged[merged.revenue>0].pivot_table('revenue',['device'],aggfunc=['count','sum','mean'])
#Sources+Devices
merged[merged.revenue>0].pivot_table('revenue',['device','source_id'],aggfunc=['count','sum','mean'])


# По анализу в разрезе по источникам очевидно, что 6 источник вовсе не приводит платящих пользователей, 7 источник практически не приводит, а 9 и 10 источники малоэффективны как по количеству платящих пользователей, так и по среднему чеку. 1-5 источники работают достаточно хорошо. 
# 
# Анализ в разрезе по устройствам показывает, что touch-устровйства приводят меньше платящих пользователей, чем desktop'ы, и средний чек таких пользователей (через touch) ниже.
# 
# Анализ в разрезе по устройствам и источникам показывает соотношение пользователей, приходящих из разных источников и разных девайсов. Так заметна значительная разница между 2-3-4 источниками на каждом устройстве. На touch-устройствах 3 и 5 источники приводят не так много платящих пользователей, в отличие от 4 источника, в сравнение с той же ситуацией на desktop-устройствах. Это может указывать на недостаточно хорошее размещение ссылок/рекламных предложений на desktop-версиях 4 источника в отличии от touch-версии сайта (или на более хорошее размещение на 3 и 5 источниках на desktop-версиях, чем на touch-версиях, что более очевидно)
# 
# Вышеизложенные факты следует учитывать при определении CPS с каждого источника ОТДЕЛЬНО (т.е. за 2 источник можно платить больше (если медиана там тоже выше), а от 6 и 7 источников вовсе отказаться (либо за минимально-возможную плату)).
# А также учитывать, что пользователи могут по-разному видеть рекламные предложения 3-4-5 источников на desktop-версиях и на touch
# 
# 
# 
# 

# Для интереса можно также посчитать конверсию с каждого источника

# In[ ]:


source_purchases = merged[merged.revenue>0].pivot_table('revenue',['source_id','device'],aggfunc=['count','sum','mean'])
source_visits = visits.pivot_table('start_dt', index=['source_id','device'],aggfunc=['count']) 
                                  #start_dt был выбран в качестве произвольного столбца для подсчёта количества 
source_pivot = pd.concat([source_purchases,source_visits],axis=1)
source_pivot['conversion'] = source_pivot[('count','revenue')]/source_pivot[('count','start_dt')]
source_pivot


# Принимая, что объединение таблиц visits и purchases ранее произошло с наименьшим количеством ошибок, было посчитано общее количество платящих и общее количество переходов. На основании этого, была посчитана конверсия по источникам и девайсам.
# Данный анализ подтвердил эффективность первого источника (как desktop, так и touch версии), а также эффективность остальных источников в desktop, за исключением 6,7,9). 

# Посчитаем, сколько мы готовы платить за один переход и за одного нового пользователя (все так же - исключая частых клиентов)

# In[ ]:


unique_uids = pd.unique(visits.uid[~visits.uid.isin(pivot1[(pivot1[('sum','revenue')]>0) 
                                      & (pivot1[('count','revenue')]>5)].index)]) # 379 762 уникальных пользователей всего побывали на сайте
                                                                                # из них НОВЫЕ пользователи (55 418), принесли 273 150 у.е.
clicks = visits.uid[visits.uid.isin(unique_uids)]  #686 714 переходов всего от 55 418 
                                                   #пользователей, принесших 273 150 заработанных у.е
                                                   # с учетом остальных пользователей, заходивших на 
                                                   # сайт, но так ничего и не купивших
print('CAC без учёта постоянных клиентов: ' + str(273150/len(unique_uids)))
print('CPC без учёта постоянных клиентов: ' + str(273150/len(clicks)))
print('CAC по первоначальным данным: ' + str(total_revenue/visitors))
print('CPC по первоначальным данным: ' + str(total_revenue/total_visits))


# Исключая покупки, сделанные постоянными пользователями (заказавших что-либо на Яндекс.Афише больше 5 раз), стоимость привлечения одного нового uid на сайт равна 0.72 у.е. а стоимость одного клика - 0.40 у.е.
# 
# Без чистки данных данные показатели получились бы равными 0.97 у.е. и 0.51 у.е. соответственно
